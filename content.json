{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"about","text":"欲以一身撼天下，须于平地起波澜。 shuhong的个人博客，中二咸鱼。 记录学习过程中的备忘，生活琐事。 勤快更新 没人关注 此站点始建于2020最初，19年是很不普通的一年，20年更是充满挑战。 从此江湖路远，是为雪走，一步一个脚印，直到世界尽头。","link":"/about/index.html"}],"posts":[{"title":"object-based programming","text":"该篇是essential c++第四章：基于对象的编程风格的归纳备忘，顺手添加了一些自己的理解。 class 基础 member function都要在class主体里面声明，可在ClassXX.h同名的.cpp文件中定义。 若在class内部定义，自动视作inline函数。non-inline的定义应该放在.cpp文件 若在外部定义，可以加上inline关键字。需要class scope resolution运算符 (classXX::functionXX) constructor &amp; destructor常用的构造函数，声明给每个参数指定了初始值： 1234567891011class Triangular{ public: Triangular (int len = 1, int bp = 1); //...}Triangular::Triangular(int len, int bp){ _length = len &gt; 0 ? len : 1; _begin_pos = bp &gt; 0 ? bp : 1; _next = _begin_pos - 1;} 由于声明提供了初始值，相当于支持三种constructor的重载。 成员初始化列表 member initialization list用于将参数传给member class object，比如Triangular 包含一个string成员。 destrcutor用于释放在object声明周期分配的资源。生命周期结束后编译器暗自调用destructor。 例如 1234567891011121314class Matrix{public： Matrix(int row, int col) //这里用了成员初始化列表,{}内传输参数给double* _pmat :_row(row), _col(col){ _pmat = new double[row * col]; } ~Matrix(){ //constructor名字前加~//注意没有参数 delete [] _pmat; }private: int _row, _col; double* _pmat;} memberwise initialization 成员逐一初始化默认的class object赋值语句会导致成员的逐一复制，但是有时候不适用，例如上述的Matrix class对应的_pmat指针，假若B复制A的话两个指针指向同一个空间，destructor重复操作两次会很危险。 solution：自定义一个copy constructor，取代默认的copy constructor. mutable &amp; constmember function若标注const，编译器得知，member function不会更改class object的内容。 每个member function可以提供const 和 non-const两个版本，调用时候根据调用的对象const与否而重载。const refercence class 参数不能调用public接口中的non-const部分（但是多数编译器只会警告）。 mutable data member 可变数据成员将变量用关键词mutable标志，例如mutable int _next;则说明对变量的改变不会破坏class object的常量性。于是乎那些改变mutable变量的接口可以被声明为const member function，即可以使用const reference class参数。 this指针有时候对象既是复制的目标，也是返回的结果。 例如tr1.copy(tr2); this指针指向member function中的调用者对象，上例中指向tr1。 编译器将Triangular&amp; Triangular::copy(Triangular &amp;tr2)转化为Triangular&amp; Triangular::copy(Triangular *tr1, Triangular &amp;tr2) 于是 tr1.copy(tr2)-&gt;copy(&amp;tr1, tr2) static class members对于一个class，static class member只有唯一一份实体，且需要定义。定义时候用上类scope运算符。 static const int _member 可以在声明时候给定初值。 static member function一般情况下，member function需要通过具体对象来调用。该对象被绑定到member function内使用的this指针，然后member function才能够访问储存在具体对象内的non-static data member。 只有对于没有访问non-static data member 的成员函数，才能定义为static member function，使用时候不需要指定具体对象，因为它和任何一个具体对象都没有瓜葛。但是需要通过class scope调用，加以区分，如Triangular::is_elem(8); Iterator class想要为一个iterator class定义运算符，需要我们类似member function那样定义。 例如 12345678class Triangular_iterator{public: Triangular_iterator(int index): _index(index-1){} //构造函数，使用成员初始化列表 bool operator== (const Triangular_iterator&amp;) const; //关键字operator指定是运算符定义private: void check_integrity() const; int _index;//维护一个索引，用来索引Triangular class中的那个静态储存容器} 1234inline bool Triangular_iterator::operator== (const Triangular_iterator &amp;rhs) const{ return _index == rhs._index;} Triangula把特殊的访问权限赋予了Triangular_iterator的member function(使用了friend机制)。 关于运算符的定义：可以写成上述member function风格，也可以是non-member function的样式，但是后者不能访问non-public member。 关于++运算符，我们定义了前置(++i)和后置(i++)两个版本，因为重载规则要求函数的参数列表唯一性，所以后置版本使用一个小trick，定义中加上了参数int，由编译器负责自动产生值为0的int参数，用户无需操心。 前置返回类型是对象的引用，例如Triangular &amp;， return *this。而后置版返回的是临时对象，注意，生命周期在使用运算符语句结束时，释放内存空间。后置版本(i++)返回的是临时变量，也解释了为何不能作为赋值语句的左值。 friend机制任何函数或者其他class的member function，都可以访问一个class的private member，前提是class在定义中的任意位置，加上一段声明，成为他的friend，例如 123class Triangular{ friend int operator* (const Triangular_iterator &amp;rhs); //加上friend关键字} 也可以建立class 之间的友谊： 123class Triangular{ friend class Triangular_iterator; //所有member function自动成为Triangular的friend} 当然，friend不是必须建立的。class A可以定义public接口返回需要的private member，就不需要建立友谊了。 copy assignment operator12Triangular tri1(8), tri2(8,9);tri1 = tri2; 这里将一个类对象赋值给另一个，默认情况下使用default memberwise copy逐一复制。但是这种方法偶尔不适用，在上文讨论过。我们需要构造copy constructor 或者 copy assignment constructor。后者可以替代默认的赋值行为，使用类对象赋值copy的源代码也可以沿用。 重载iostream运算符想要通过iostream运算符 输入 / 输出 类对象的内容，就需要对 &gt;&gt; / &lt;&lt; 运算符重载。 例如 1234ostream&amp; operator&lt;&lt; (ostream &amp;os, const Triangular &amp;rhs){ //... return os; //返回os，是为了串接多个&lt;&lt;，品一下：cout &lt;&lt; tri1 &lt;&lt; endl;} 不能把&lt;&lt;作为class的member function定义，因为member function都要求左操作数隶属于同一个类的对象。 倘若这样定义，就会变成 tri1 &lt;&lt; cout &lt;&lt; endl;。迷惑行为，且串接行为会失败。 pointer to member function如下是一个class的定义，他是一个通用的数列class： 12345678910111213141516171819202122class num_sequence{public: typedef void (num_sequence::*PtrType)(int);//声明PtrType是一个指针，指向num_sequence的member function，返回void，参数是int。 void set_sequence(int); //设置_elem和_pmf. int elem(int); //根据pos返回序列某位置的数值。 //这两个static成员函数充当访问private + static data member的接口。 static int num_of_sequences(){ return num_sequence::num_seq}; //返回目前支持的序列种类个数(7) static int ns_type(int){...}; //根据序号，返回不同序列对应的函数地址func_tbl。用于set_sequence()。 void fibonacci(int); //序列生成函数共6个，略 private: vector&lt;int&gt;* _elem; //指向当前序列对应的容器 PtrType _pmf; //Pointer to Member Function static const int num_seq = 7; static PtrType func_tbl[num_seq]; //存放6个序列生成函数的地址 static vector&lt;vector&lt;int&gt; &gt;seq; //seq存放六个序列。这里注意int&gt;后的空格。} 之后要对static data member进行定义。 pointer to member function和pointer to function的区别就是，前者需要通过特定的class对象调用。这个对象就是这个member function内的this指针指向的对象。 member_function elem()的实现如下： 123456789int num_sequence::elem(int pos){ if(! check_integrity(pos)) //检查输入pos(位置)的合理性 return 0; if(pos &gt; _elem-&gt;size()) //若当前储存的元素未包含这个位置，就调用生成函数产生新元素 (this -&gt; *_pmf)(pos); //调用对象的生成函数 return (*_elem)[pos - 1];} 定义一个class的大致step（基于本章总结，可能不完善） 是否定义friend函数/class？（friend声明不受权限影响，可定义在class开头） 分析问题。找全需要的data member in private。 可能需要全局的static变量。 可能需要static function来操作static变量。 定义constructor和destructor。 可能需要定义copy constructor 和 copy assignment constructor（成员的逐一初始化不适用的时候）。 constructor的内部（当然也包括别的member function），可能含有函数内的局部static变量。比如用来区分构造不同的class实例对象。 考虑输入输出 iostream重载问题（不能定义为member function）。一般也不给予friend权限，通过4.2/3的接口实现。 读取static data member的接口 写入static data member的接口 其他计算/功能接口 文末附上自家猫猫看收集照片一张","link":"/2020/02/21/object-based%20programming/"},{"title":"Xen and the art of virtualization(SOSP'03)","text":"xen是一个x86 半虚拟化vmm，允许多个商品级系统共享传统硬件，拥有安全的资源管理，同时几乎不牺牲性能和功能。能够同时支持100台虚拟机，在多个benchmark上优于竞争对手。 introduction成功的机器分割（虚拟化）面临三个挑战： vm之间彼此隔离，一个vm的执行不能影响别的vm 支持多种os，并且支持多种应用运行于其上。 虚拟化引入的性能损失应该较低。 xen host商品级os(XenoLinux based on Linux 2.4)，不过会引入源代码的修改。（该论文是sosp03的文章，当时还没有进行完windows和netBSD的移植，现在的vmm不需要再对os进行适配工作了） 在ISP的服务器上运行虚拟机，对每个虚拟机进行权限控制，用户通过支付不同价格来获取相应资源。（云计算模式的雏形） 如何在机器上运行多个互不相干的应用？简单做法：不同的用户在自己的文件夹下安装程序运行。问题： 不同的应用需要各自的复杂配置，系统管理耗时巨大 资源争夺：调度优先级，磁盘IO，带宽分配，内存分配 隔离性不佳，很靠默契 超额订阅，供不应求 一些方案如Qlinux(QoS enhanced linux kernel)实现了cpu，磁盘和带宽资源的“公平”调度，但是资源利用的统计难以完善，buffer cache和页替换导致的进程间通信。 xen以操作系统为粒度进行资源分配和隔离。用户可自定义执行环境，对于每个windows用户而言，有独立的注册表。 xen的方法和综述全虚拟化：x86架构对于全虚拟化的支持很不友好：当权限不够的时候，执行一些特权指令会直接失败，而不是产生一个方便的trap。VMware的esx系统能够动态的重写客户机的部分机器码，使得可以在需要vmm干预的地方生成trap，捕捉并执行non_trapping instructions。 全虚拟化的弊端:实现复杂，牺牲性能。有时候客户机想要看到真实资源而不是虚拟化的抽象资源。如果客户机得到系统时间，就能处理tcp timeout和测量RTT；而提供机器地址则可以使用页着色等技术优化性能。 xen的半虚拟化技术： 提供接近但与底层硬件不同的抽象物理层 需要修改客户机的os，但是不修改abi，因此不影响应用层程序。 虚拟机接口 内存管理而客户机可以直接读页表，但是必须批处理更新，并且操作经过xen验证。一个客户机可能被分配不连续的物理页面。 cpu客户机的权限等级必须比xen更低。如果处理架构只有两个等级，则与用户程序同杨等级。对于异常：拥有handler的描述符表。对于系统调用：快速的系统调用路径，不用陷入xen执行。对于硬件中断：利用事件机制取代。对于时间：客户机可获取物理机时间。 设备I/O利用环形缓冲区描述符表，进行异步的数据I/O。xen异步通知客户机获取数据。 移植一个os到xen的开销表2windows xp在 architecture independent OS code （体系结构无关的os代码）方面需要大量移植，因为它使用了很多数据结构用来访问页表项。而linux使用了预处理宏来进入页表项，半虚拟化的翻译和调用更加容易。 控制&amp;管理理念：分离mechanism和policyxen负责最基本的控制操作（机制），复杂的应用层管理软件（策略）运行在客户机os自身。图1domain0在xen启动时候创建，用来运行管理软件。control interface用来创建和终止domain，控制调度参数，控制内存分配。还可以创建虚拟块设备和网卡，并且自定义I/O规则(which domain can access, ip filter)。control interface和一些统计信息和domain0的控制平面软件对接，控制平面软件可以方便的管理整个xen。 具体设计控制流的转移：hypercall &amp; eventshypercall是自上而下的同步软件trap，请求hypervisor执行一些权限操作，例如更新页表。events机制是自下而上的非同步信号，用来传递I/O信息等。类似于传统的屏蔽中断，domain也可以设置一个xen可读的软间flag，使得event的处理延迟。 数据运输：I/O rings图2一个ring由domain分配。descriptors指向domain分配的buffers。两对pro-con指针相互追赶，这个ring结构可以被多种io复用，例如request代表domain分配的数据包buffer，response代表数据包到达buffer。domain可以设置request(hypercall)和response(event notification)的批处理阈值，来平衡延迟和吞吐量。 子系统的虚拟化cpu调度Borrowed Virtual Time (BVT)调度算法，对于延迟敏感。 timer同时维护real time和virtual time（用于guest os之上的应用程序调度）。 页表vmware esx对于x86的处理方式是为每个guest os 提供MMU不可见的virtual page table，然后hypervisor负责trap的处理，以及在它和MMU可见的影子页表之间传递更改。xen：使用MMU注册guest os页表，只暴露给gOS读权限。页表更新则通过hypercall的方式交给xen处理。 物理内存domain的静态内存在初始化时候分配，彼此之间隔离，但是有最大上限reservation。每个domain维护自己的一个translation array来保存物理地址到硬件地址的mapping。在xen中保存一个shared版本。 网络VFR(virtual firewall router)是一个抽象层，几块虚拟网卡逻辑绑定在其上。每个网卡包含出入两个IO ring，同时每个ring和一个(，)规则列表关联，控制收发行为，列表由domain0维护。 磁盘domains通过virtual block devices (VBDs)抽象层访问存储设备。VBD包含一个列表来包含控制访问的信息。gOS的disk调度算法可以对IO请求重排序，满足分级服务的要求。零拷贝DMA发生在磁盘和domain的pinned内存页面上。 创建新domainnew domain is mostly delegated to Domain0 which uses its privileged control interfaces (Section 2.3) to access the new domain’s memory and inform Xen of initial register state. 测试评估All the experiments were performed on a Dell 2650 dual processor 2.4GHz Xeon server with 2GB RAM, a Broadcom Tigon 3 Gigabit Ethernet NIC, and a single Hitachi DK32EJ 146GB 10k RPM SCSI disk. 四号选手UML is a port of Linux to run as a user-space process on a Linux host. Linux version 2.4.21 was used throughout, compiled for architecture i686. Redhat 7.2. ext3. 性能对比A range of server-type workloads。xen和vmware暂时不支持多处理器系统，因此测试物理机开启的是单核配置。 图PostgreSQL 7.1.3 database，OSDB开源数据库benchmarkIR：数据检索TP：事务处理 dbench program is a ﬁle system benchmark derived from the industry-standard ‘NetBench’.examine the throughput experienced by a single client performing around 90,000 ﬁle system operations. SPEC WEB99 is a complex application-level benchmark for evaluating web servers and the systems that host them.测试结果反应OS整体性能，including ﬁle system and networkThe benchmark is CPU-bound, and a signiﬁcant proportion of the time is spent within the guest OS kernel, performing network stack processing, ﬁle system operations, and scheduling between the many httpd processes that Apache needs to handle the offered load. 操作系统benchmarks测试更小的子系统24/37测试上，性能接近单处理器linux kernel，优于SMP kernel。 表3：fork, exec and sh performance worse，因为需要大量的页表更新，而页表更新需要xen的认证过程。 表4：不同大小的working set内，进程上下文切换的时间。as it executes a hypercall to change the page table base. 表5mmap &amp; page fault延迟。 表6：Both sender and receiver applications were conﬁgured with a socket buffer size of 128kBa median of 9 experiments transferring 400MB 500-byte MTU for the PPP拨号客户端用的MTUXenoLinux virtual network driver使用了page-ﬂipping technique 多vm并发场景单物理机多vm运行单程序 vs 单物理机多程序 1，2，4，8，16web99 benchmark进程，运行在SMP linux上。xen则是运行相应数量的vm，每个为单处理器的xenolinux。图4Achieving good SPEC WEB99 scores requires both high throughput and bounded latency. if a client request gets stalled due to a badly delayed disk read, then the connection will be classed as non conforming and won’t contribute to the score. 图52 instances开始利用上物理机的双核性能。 Increasing the number of domains further causes some reduction in aggregate throughput which can be attributed to increased context switching and disk head movement. 8diff：给8个vm不同的优先级in the OLTP case, domains given a larger share of resources to not achieve proportionally higher scores: The high level of synchronous disk activity highlights a weakness in our current disk scheduling algorithm causing them to under-perform. 性能隔离4 domains,两个分别运行OSDB和Web99，第三个疯狂创建小文件；第四个疯狂fork，消耗虚拟内存，到达上限之后free page，再重新循环。前两个domain的性能损失只有4% 和 2%。 可扩展性图运行RH 7.2默认的守护进程组，以及ssh+apache server内存上限是64MB 后续目标讨论 公开发布产品 优化块设备的相关算法 优化VFR层的网络规则，更好地过滤反社会网络行为 xenoserver的有偿分级服务 完善xp和netBSD的移植工作 结论xen是部署网络服务的绝佳平台，如流媒体转码，动态网站镜像，多媒体游戏，智能proxy代理等。对于短时服务来说，快速的部署和方便的配置管理是很重要的。对比原生系统出色的性能损耗和隔离性。后续完成windows和netBSD的移植工作。","link":"/2020/01/02/xen%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"半虚拟化","slug":"半虚拟化","link":"/tags/%E5%8D%8A%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"系统","slug":"系统","link":"/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"论文阅读","slug":"论文阅读","link":"/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}]}